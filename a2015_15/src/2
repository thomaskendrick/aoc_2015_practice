use std::str::FromStr;

struct Ingredient {
    name: String,
    capacity: u8,
    durability: u8,
    flavour: u8,
    texture: u8,
}

#[derive(Debug)]
struct IngredientError;
impl std::fmt::Display for IngredientError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Failed to parse ingredient")
    }
}

impl FromStr for Ingredient {
    type Err = IngredientError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let spl = s.split(" ");

        Ok(Ingredient {
            name: spl
                .next()
                .ok_or(IngredientError)?
                .strip_suffix(".")
                .ok_or(IngredientError)?
                .to_owned(),
            capacity: spl
                .nth(1)
                .ok_or(IngredientError)?
                .parse()
                .map_err(|e| IngredientError)?,
            durability: spl
                .nth(1)
                .ok_or(IngredientError)?
                .parse()
                .map_err(|e| IngredientError)?,,
            flavour: (),
            texture: (),
        })
    }
}

pub fn part_a(input: &str) -> i64 {
    for line in input.trim().split('\n') {}
    0
}

#[cfg(test)]
mod tests {
    const INPUT: &str = include_str!("input.txt");

    #[test]
    fn part_a() {
        assert_eq!(super::part_a(INPUT), 0);
    }
}
